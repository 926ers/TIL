# 비동기 io와 서버

## 요청당 쓰레드 모델
요청당 쓰레드 생성 
요청 100개 쓰레드 100개
클라이언트 데이터 읽기 대기 -> 디비 데이터 전송 대기 -> 디비 데이터 읽기 -> 클라이언트에 데이터 쓰기 대기
io 대기 시간이 처리 시간에서 많은 비중 차지 -> cpu가 노는 시간이 많다

컨텍스트 스위칭
쓰레드 프로세스 전환에 시간 발생

고부하 상황시 io대기 cpu 낭비 증가
쓰레드 증가 -> 컨텍스 스위칭 비용 증가, 메모리 증가

결론: 자원 사용 급증 및 처리량 향상 제한, 응답 시간 증가
- 동시 접속 클라이언트 제한

## 비동기 io
io가 끝나길 대기하지 않음
io 완료시 콜백 형태로 결과를 받음
- io처리애는 고정된 개수의 스레드 사용
큐와 이벤트 루프를 사용해 구현

io에 대한 대기 시간 없음
스레드 수 일정
ex) 1.5G 메모리로 120k 동시 연결 처리 (네티, r2dbc)

하지만
비동기 처리에 따른 복잡도 증가
코드 복잡
디버깅 어려움 - 실행 시점이나 스레드가 달라서
대량 트래픽이 아니면 효과 적따
io 위주로 처리하자
동기와 비동기가 섞이면 안됨

정리
쓸데없이 쓰지 말자
비동기는 성능상 필요할때만 쓰자
비동기 io 시도전에 다른 성능 용인 확인하자 -> 캐시나 디비 등

## 외부 서비스의 응답 시간과 성능 저하
외부 연동을 비동기로 처리하면 외부 서비스의 성능의 tps 영향 감소
일정 수준의 품질 유지한다는 이점

# 비동기 처리 방식
1. 별도 스레드
2. 연동 데이터를 디비에 저장하고 별도의 스레드 프로세스로 처리
3. 연동 데이터를 메시징 시스템에 저장하고 별도으 스레드 프로세스로 초리

## 별도 스레드
`@ASYNC`
구현 쉽다
트랜잭션은? -> 커밋이후 처리하자
서비스 재시작시 작업 유실
외부 연동 실패시 재처리
재처리 필요성이 낮은 외부 연동에 적합
메일, 푸시 발송 류

## 디비 사용
연동 데이터를 디비에 저장
별도의 스레드가 연동처리
트랜잭션 처리 쉬움
누락이 없어야 하는 연동에 적합
포인트 적립

## 메세징 시스템
카프카
별도 스레드 프로세스가 연동 처리
대량 데이터 처리에 이점
데이터 유실 가능성 고려 -> 레플리카
외부 연동 실패시 재처리 용이

# 정리
비동기는 복잡도 증가
재처리 트랜잭션 제약이 적으면 별도 스레드로 비동기 처리하자
연동 성능 요구가 높다면 디비 메시징 조합 고려하자